# Writing Trajectory Context - Implementation Document

## Overview
This document details the implementation of the **Writing Trajectory Context** for IdeaWalker. The module uses **Domain-Driven Design (DDD)** principles and **Event Sourcing** to ensure strict traceability of writing decisions, revisions, and defenses.

## 1. Architecture

### Domain Layer (`src/domain/writing`)
The core logic is encapsulated in the `WritingTrajectory` Aggregate Root.

*   **Aggregate Root**: `WritingTrajectory`
    *   Manages the lifecycle of a writing project from Intent to Final Draft.
    *   Enforces invariants (e.g., "Cannot advance stage without Purpose" and only allows sequential stage transitions).
    *   Records all state changes as Domain Events.
*   **Entities**:
    *   `DraftSegment`: Represents a section of text (Introduction, Argument, etc.). Traceable by ID and version.
    *   `DefenseCard`: Represents a specific challenge or question generated by the AI to test the coherence of the text.
    *   `RevisionDecision`: Captures the *why* behind a text change (Operation + Rationale).
*   **Value Objects**:
    *   `WritingIntent`: Purpose, Audience, Core Claim, Constraints.
    *   `TrajectoryStage`: Enum (Intent -> Outline -> Drafting -> Revising -> Consolidating -> Defense -> Final).

### Infrastructure Layer (`src/infrastructure/writing`)
Persistence is handled via a custom file-system-based Event Store.

*   **Event Sourcing**:
    *   `WritingEventStoreFs`: Appends events to `.ndjson` files (`writing/trajectories/<uuid>/events.ndjson`).
    *   **Synchronous Storage**: Writes are performed synchronously to `std::ios::app` to ensure data integrity and prevent race conditions.
    *   All domain events include timestamps to preserve ordering and enable audits.
*   **Repository**:
    *   `WritingTrajectoryRepositoryFs`: Rehydrates `WritingTrajectory` objects by replaying stored events (`applyEvent`).
    *   Handles serialization/deserialization of polymorphic events (JSON).

### Application Layer (`src/application/writing`)
Orchestrates the flow between UI and Domain.

*   **`WritingTrajectoryService`**:
    *   Exposes Use Cases: `createTrajectory`, `addSegment`, `reviseSegment`, `advanceStage`, `addDefenseCard`.
    *   **Caching**: Implements an eager read-through cache (`m_trajectoryCache`) to optimize UI rendering performance and minimize disk I/O.
    *   **Coherence Lens**: Integrates `CoherenceLensService` to analyze the trajectory for logical gaps.
    *   **ID Generation**: Uses a random alphanumeric generator to avoid collisions without external UUID dependencies.

### UI Layer (`src/ui/panels`)
ImGui-based panels for interaction.

*   **`WritingPanels` (Trajectory & Editor)**:
    *   Split-view editor with segment list.
    *   **Revision Enforcement**: Blocks saving changes without a Revision Rationale (Clarify, Expand, etc.), ensuring traceability.
    *   **Quality Feedback**: Real-time feedback on text density and term retention.
*   **`DefensePanel`**:
    *   Visualizes "Defense Cards" (Pending/Rehearsed/Passed).
    *   Allows generating AI challenges based on current text.
    *   Supports rehearsal input with automatic text wrapping.
*   **`UiRenderer` integration**:
    *   "View" menu toggles to recover closed panels.

## 2. Key Features Implemented

### Persistence & Stability
*   **Robust Event Store**: Fixed race conditions causing data corruption. Events are now append-only and thread-safe.
*   **Crash Prevention**: Added exception handling boundaries in the UI to prevent "window closed" crashes during file operations.
*   **Data Recovery**: Deleted corrupted artifacts and implemented validation logic in `WritingTrajectory::createEmpty`.

### "Traceable Revision" Workflow
1.  User adds a segment (creates blank entry).
2.  User drafts content in memory.
3.  User must provide a **Rationale** to save.
4.  System records `SegmentRevised` event with the diff and the reason.

### "Defense Mode" Workflow
1.  **Generate**: System uses LLM (via LocalService) or heuristic to create "Defense Cards".
2.  **Rehearse**: User answers the challenge in the UI.
3.  **Validate**: User marks as "Rehearsed" or "Passed".

## 3. Directory Structure
```
src/
├── domain/
│   └── writing/
│       ├── entities/       # DefenseCard, DraftSegment, RevisionDecision
│       ├── events/         # WritingEvents.hpp (Variants)
│       ├── services/       # CoherenceLens, DefensePrompt, RevisionQuality
│       ├── value_objects/  # Intent, Stage
│       └── WritingTrajectory.hpp
├── infrastructure/
│   └── writing/            # FsRepository, FsEventStore
├── application/
│   └── writing/            # WritingTrajectoryService
└── ui/
    └── panels/             # WritingPanels.cpp, DefensePanel.cpp
```

## 4. Verification
The system has been verified manually:
- [x] Creation of Trajectory (Persistence Verified)
- [x] Segment Addition & Revision (Rationale Logic Verified)
- [x] Defense Mode Generation & Interaction (UI Layout Verified)
- [x] Recovery from closed windows via View menu.
