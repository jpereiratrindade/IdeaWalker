#include "infrastructure/PersonaOrchestrator.hpp"
#include <chrono>
#include <iomanip>
#include <sstream>
#include <iostream>
#include <nlohmann/json.hpp>

namespace ideawalker::infrastructure {

using json = nlohmann::json;

namespace {

std::tm ToLocalTime(std::time_t tt) {
    std::tm tm = {};
#if defined(_WIN32)
    localtime_s(&tm, &tt);
#else
    localtime_r(&tt, &tm);
#endif
    return tm;
}

std::string NormalizeToken(const std::string& value) {
    std::string out;
    out.reserve(value.size());
    for (char ch : value) {
        unsigned char c = static_cast<unsigned char>(ch);
        if (std::isalnum(c)) {
            out.push_back(static_cast<char>(std::tolower(c)));
        }
    }
    return out;
}

bool PersonaFromToken(const std::string& value, domain::AIPersona& outPersona) {
    std::string token = NormalizeToken(value);
    if (token == "brainstormer") {
        outPersona = domain::AIPersona::Brainstormer;
        return true;
    }
    if (token == "analistacognitivo") {
        outPersona = domain::AIPersona::AnalistaCognitivo;
        return true;
    }
    if (token == "secretarioexecutivo") {
        outPersona = domain::AIPersona::SecretarioExecutivo;
        return true;
    }
    if (token == "scientificobserver" || token == "cientista") {
        outPersona = domain::AIPersona::ScientificObserver;
        return true;
    }
    return false;
}

} // namespace

PersonaOrchestrator::PersonaOrchestrator(OllamaClient& client)
    : m_client(client) {}

std::optional<domain::Insight> PersonaOrchestrator::Orchestrate(const std::string& model,
                                                               const std::string& rawContent, 
                                                               bool fastMode, 
                                                               std::function<void(std::string)> statusCallback) {
    if (statusCallback) statusCallback(fastMode ? "Iniciando modo rápido (CPU Optimization)..." : "Iniciando processamento...");
    
    std::string finalContent;
    std::vector<std::string> tags = {"#AutoGenerated"};
    std::vector<domain::CognitiveSnapshot> snapshots;

    if (fastMode) {
        if (statusCallback) statusCallback("Modo Rápido: Analisando diretamente...");
        tags.push_back("#FastMode");
        
        std::string prompt = PromptCatalog::GetSystemPrompt(domain::AIPersona::AnalistaCognitivo);
        auto res = m_client.generate(model, prompt, rawContent, false);
        
        if (res) {
            finalContent = *res;
            snapshots.push_back(CreateSnapshot(domain::AIPersona::AnalistaCognitivo, rawContent, finalContent));
        } else {
            return std::nullopt;
        }

    } else {
        if (statusCallback) statusCallback("Orquestrador: Diagnosticando...");
        tags.push_back("#Orchestrated");
        std::string orquestradorPrompt = PromptCatalog::GetSystemPrompt(domain::AIPersona::Orquestrador);
        auto planOpt = m_client.generate(model, orquestradorPrompt, rawContent, true);
        
        if (!planOpt) return std::nullopt;
        
        std::vector<domain::AIPersona> sequence;
        ParsePlan(*planOpt, sequence, tags);

        if (sequence.empty()) {
            sequence.push_back(domain::AIPersona::AnalistaCognitivo);
        }

        std::string currentText = rawContent;
        for (auto persona : sequence) {
            std::string pName = (persona == domain::AIPersona::Brainstormer) ? "Brainstormer" :
                                (persona == domain::AIPersona::AnalistaCognitivo) ? "Analista Cognitivo" : "Secretário";
            if (statusCallback) statusCallback("Executando: " + pName + "...");
            
            std::string pPrompt = PromptCatalog::GetSystemPrompt(persona);
            auto res = m_client.generate(model, pPrompt, currentText, false);
            
            if (res) {
                snapshots.push_back(CreateSnapshot(persona, currentText, *res));
                currentText = *res;
                
                // Tagging for Persistence Bridge
                if (persona == domain::AIPersona::ScientificObserver) {
                    tags.push_back("#ScientificObserver");
                }
            } else {
                snapshots.push_back(CreateSnapshot(persona, currentText, "[ERROR: Failed to generate]"));
            }
        }
        finalContent = currentText;
    }

    if (statusCallback) statusCallback("Finalizando...");

    try {
        auto now = std::chrono::system_clock::now();
        auto in_time_t = std::chrono::system_clock::to_time_t(now);
        std::stringstream ss;
        std::tm localTime = ToLocalTime(in_time_t);
        ss << std::put_time(&localTime, "%Y-%m-%d %X");

        domain::Insight::Metadata meta;
        meta.id = std::to_string(in_time_t);
        meta.date = ss.str();
        meta.tags = tags;

        std::string titlePrefix = "# Título: ";
        size_t titlePos = finalContent.find(titlePrefix);
        if (titlePos != std::string::npos) {
            size_t startInfo = titlePos + titlePrefix.length();
            size_t endOfLine = finalContent.find('\n', startInfo);
            if (endOfLine != std::string::npos) {
                meta.title = finalContent.substr(startInfo, endOfLine - startInfo);
            } else {
                 meta.title = finalContent.substr(startInfo);
            }
            if (!meta.title.empty() && meta.title.back() == '\r') meta.title.pop_back();
        } else {
             meta.title = "Thought " + ss.str();
        }

        domain::Insight insight(meta, finalContent);
        for(const auto& snap : snapshots) insight.addSnapshot(snap);
        return insight;
    } catch (...) {
        return std::nullopt;
    }
}

domain::CognitiveSnapshot PersonaOrchestrator::CreateSnapshot(domain::AIPersona persona,
                                                            const std::string& input,
                                                            const std::string& output) {
    domain::CognitiveSnapshot snap;
    snap.persona = persona;
    snap.textInput = input;
    snap.textOutput = output;
    
    if (persona == domain::AIPersona::Brainstormer) snap.state = domain::CognitiveState::Divergent;
    else if (persona == domain::AIPersona::AnalistaCognitivo) snap.state = domain::CognitiveState::Convergent;
    else if (persona == domain::AIPersona::SecretarioExecutivo) snap.state = domain::CognitiveState::Closing;
    else snap.state = domain::CognitiveState::Unknown;
    
    auto now = std::chrono::system_clock::now();
    auto in_time_t = std::chrono::system_clock::to_time_t(now);
    std::stringstream ttss;
    std::tm localTimeSnap = ToLocalTime(in_time_t);
    ttss << std::put_time(&localTimeSnap, "%Y-%m-%d %X");
    snap.timestamp = ttss.str();
    
    return snap;
}

void PersonaOrchestrator::ParsePlan(const std::string& planJson, 
                                     std::vector<domain::AIPersona>& outSequence, 
                                     std::vector<std::string>& outTags) {
    try {
        auto data = json::parse(planJson);
        if (data.contains("primary_tag") && data["primary_tag"].is_string()) {
            std::string tagLine = data["primary_tag"].get<std::string>();
            if (!tagLine.empty()) outTags.push_back(tagLine);
        }
        if (data.contains("sequence") && data["sequence"].is_array()) {
            for (const auto& item : data["sequence"]) {
                if (!item.is_string()) continue;
                domain::AIPersona persona;
                if (PersonaFromToken(item.get<std::string>(), persona)) {
                    outSequence.push_back(persona);
                }
            }
        }
    } catch (...) {
        // Fallback or leave empty for default
    }
}

} // namespace ideawalker::infrastructure
