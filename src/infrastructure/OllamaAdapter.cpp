/**
 * @file OllamaAdapter.cpp
 * @brief Implementation of the OllamaAdapter class.
 */
#include "infrastructure/OllamaAdapter.hpp"
#include <httplib.h>
#include <nlohmann/json.hpp>
#include <iostream>
#include <chrono>
#include <iomanip>
#include <sstream>

using json = nlohmann::json;

namespace ideawalker::infrastructure {

namespace {

std::tm ToLocalTime(std::time_t tt) {
    std::tm tm = {};
#if defined(_WIN32)
    localtime_s(&tm, &tt);
#else
    localtime_r(&tt, &tm);
#endif
    return tm;
}

} // namespace

OllamaAdapter::OllamaAdapter(const std::string& host, int port)
    : m_host(host), m_port(port) {}

std::optional<domain::Insight> OllamaAdapter::processRawThought(const std::string& rawContent) {
    httplib::Client cli(m_host, m_port);
    cli.set_read_timeout(60); // LLMs take time

    json requestData = {
        {"model", m_model},
        {"prompt", 
            "Você é um Parser de Texto estrito. Sua função é converter pensamentos desorganizados em Markdown estruturado para um sistema de software.\n\n"
            "REGRAS RÍGIDAS DE SAÍDA:\n"
            "1. NÃO use blocos de código (```markdown). Retorne apenas o texto cru.\n"
            "2. NÃO inclua introduções nem conclusões.\n"
            "3. As Ações DEVEM usar estritamente o formato de checkbox: \"- [ ] Descrição da tarefa\".\n"
            "4. Mantenha os headers exatos como abaixo.\n\n"
            "ESTRUTURA OBRIGATÓRIA:\n"
            "# Título: [Um Título Curto]\n\n"
            "## Insight Central\n"
            "(Resumo em 1 parágrafo)\n\n"
            "## Pontos Principais\n"
            "- (Lista de bullets)\n\n"
            "## Ações\n"
            "- [ ] (Ação concreta 1)\n"
            "- [ ] (Ação concreta 2)\n\n"
            "## Conexões\n"
            "- [[Conceito Relacionado]]\n\n"
            "Texto a processar:\n\n" + rawContent
        },
        {"stream", false}
    };

    auto res = cli.Post("/api/generate", requestData.dump(), "application/json");

    if (res && res->status == 200) {
        try {
            auto body = json::parse(res->body);
            std::string responseText = body.value("response", "");

            // Simple metadata generation for now
            auto now = std::chrono::system_clock::now();
            auto in_time_t = std::chrono::system_clock::to_time_t(now);
            std::stringstream ss;
            std::tm localTime = ToLocalTime(in_time_t);
            ss << std::put_time(&localTime, "%Y-%m-%d %X");

            domain::Insight::Metadata meta;
            meta.id = std::to_string(in_time_t);
            meta.title = "Structured Thought";
            meta.date = ss.str();
            meta.tags = {"#AutoGenerated"};

            return domain::Insight(meta, responseText);
        } catch (...) {
            return std::nullopt;
        }
    }

    return std::nullopt;
}

std::optional<std::string> OllamaAdapter::consolidateTasks(const std::string& tasksMarkdown) {
    httplib::Client cli(m_host, m_port);
    cli.set_read_timeout(60);

    json requestData = {
        {"model", m_model},
        {"prompt",
            "Você é um consolidadores de tarefas. Receberá uma lista de tarefas com checkboxes, "
            "possivelmente duplicadas ou com redações semelhantes.\n\n"
            "REGRAS RÍGIDAS DE SAÍDA:\n"
            "1. Retorne APENAS linhas no formato de checkbox: \"- [ ] Descrição da tarefa\".\n"
            "2. Não inclua cabeçalhos, explicações, nem blocos de código.\n"
            "3. Remova duplicatas e unifique tarefas semanticamente equivalentes.\n"
            "4. Reescreva para uma redação clara, curta e acionável.\n"
            "5. Se houver estados diferentes para tarefas equivalentes, use o estado mais avançado: "
            "feito (- [x]) > em andamento (- [/]) > a fazer (- [ ]).\n"
            "6. Não invente novas tarefas.\n\n"
            "Tarefas a consolidar:\n\n" + tasksMarkdown
        },
        {"stream", false}
    };

    auto res = cli.Post("/api/generate", requestData.dump(), "application/json");
    if (res && res->status == 200) {
        try {
            auto body = json::parse(res->body);
            return body.value("response", "");
        } catch (...) {
            return std::nullopt;
        }
    }

    return std::nullopt;
}

} // namespace ideawalker::infrastructure
